/*
    统计所有小于非负整数 n 的质数的数量。

    示例:

    输入: 10
    输出: 4
    解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
    
*/
/*
    很经典的一道题
    逐个判断肯定超时
    所有的质数都是奇数 2除外
    判断n的因数时只需判断到sqrt(n) 这是我能想到的优化步骤
    
    更好的方法是厄拉多塞筛法 其思想是一个素数的倍数一定不是素数，也就是在找到一个素数之后，将其倍数从剩余数字中去掉
    这种方法需要一个额外的辅助数组来记录那些数字被标记为素数，哪些数字不是素数
    
    更好的线性方法是欧拉筛法
    在厄拉多塞筛法中中有合数被重复筛选，降低了效率
    由于是递增判断的 一个合数肯定被其能将其分解的最小质数筛掉过
    例如30 2*15 和 5*6都能将30筛除  但是在质数2的时候已经筛掉了，在质数5的时候就没有必要再次筛除30
    想要算法达到线性，就要保证每一个合数仅被筛掉一次
*/
class Solution {
public:
    int countPrimes(int n) {
        
        if(n<=2) return 0;
        vector<bool> flagMap(n,false);
        int res=0;
        
        /*
        // 厄拉多塞筛法
        for(int i=2;i<n;i++)
        {
            if(flagMap[i]==false)
            {
                // 关键是这里为什么可以直接在false的时候判断是素数  而不用手动验证呢？
                // 人为的从2开始，我们知道2是质数
                // 可能是因为这样可以保证所有合数都被筛掉 而且每个合数被筛不止一次
                res++;
                for(int j=2;i*j<n;j++)
                    flagMap[i*j]=true;
            }
        }
        */
        // 欧拉筛法  欧拉筛法还需要一个数组来记录之前遇到的所有质数
        // 所有的合数都可以拆成质数乘积的表示
        
        vector<int> prime;
        for(int i=2;i<n;i++)
        {
            if(flagMap[i]==false)
            {
                res++;
                prime.push_back(i);
            }
            for(int j=0;j<res&&i*prime[j]<n;j++)
            {
                flagMap[i*prime[j]]=true;
                if(i%prime[j]==0) break;
            }
        }
        return res;
        
    }
};