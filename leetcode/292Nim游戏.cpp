/*
    你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

    你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

    示例:

    输入: 4
    输出: false 
    解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
         因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
*/
/*
    用树的方式 类似于回溯可以把所有的可能都写出来，但是感觉效率太低了
    其实后一步的解和上一步的解有关系，感觉像是dp
    
    自己写了写感觉有规律 没找到。。。。
    评论区里说这叫巴什博奕
    
    巴什博奕更通用的描述是 共n个石子，每个人可拿1到m个石子
    当n%(m+1)!=0的时候 先手总是能赢
    因为可以拿1到m个 所以面对m+1个石子的一方一定会输掉比赛
    我们考虑往一般情况推广

    设当前的石子数为n=k∗(m+1)+r
    先手会首先拿走r个，接下来假设后手拿走x个，先手会拿走m+1−x个，这样博弈下去后手最终一定失败

    设当前的石子数为n=k∗(m+1)
    假设先手拿x个，后手一定会拿m+1−x个，这样下去先手一定失败
*/
class Solution {
public:
    bool canWinNim(int n) {
        return n%4!=0;
    }
};