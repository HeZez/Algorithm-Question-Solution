/*
    初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。

    示例:

    输入: 3
    输出: 1 
    解释: 
    初始时, 灯泡状态 [关闭, 关闭, 关闭].
    第一轮后, 灯泡状态 [开启, 开启, 开启].
    第二轮后, 灯泡状态 [开启, 关闭, 开启].
    第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

    你应该返回 1，因为只有一个灯泡还亮着。
*/
/*
    最直接的想法，用一个数组记录每一位开关的状态，之后手动模拟整个过程 最后统计开关开启的个数

    这个问题 可以看成是每一位 是之前数字整数倍的个数  例如位置6 最开始是关闭的  1的整数倍包含6
    2的整数倍包含6 3的整数倍也包含6 6的整数倍也包含6 开关状态被改变了4次  所以最后位置6是关闭的
    这样用一个数组；来计数就可以了 不过时间复杂度为O(n^2) 测试用例中存在1000w这样的大数 会超时

    更进一步的想法 来自评论区：
    根据之前的分析 开关被开偶数次最终结果是关  奇数次是开 那么问题变成了统计因子的个数
    仔细想一想 一个数n 因子是成对出现的 i*j=k  i和j一对  这样的话 一般因子数都是偶数
    什么时候会出现奇数呢？ i*i=k的情况 也就是可以开方的数字
    问题可以转化成小于等于n的可开方数字

    恕我愚笨 可以再一次优化， 不需要枚举 结果其实就是sqrt(n)下取整
*/
class Solution {
public:
    int bulbSwitch(int n) {
        /*
        // 比较直观的想法 n^2时间复杂度 会超时
        vector<int> count(n+1, 0);
        int j=1;
        for(int i=1;i<=n;i++)
        {
            j=1;
            while(i*j<=n)
            {
                count[i*j]++;
                j++;
            }
        }
        // 最后统计个数
        int result=0;
        for(auto item: count)
        {
            if(item%2==1)
             result++;
        }
        return result;
        */

        /*
        //方案二 计算可开方数字个数
        int result=0;
        for(int i=1;i<=n;i++)
        {
            // 比较暴力的判断平方根是否为整数
            if( int(sqrt(i))*int(sqrt(i)) == i )
                result++;
        }
        return result;
        */

        //方案三
        int result=int(sqrt(n));
        return result;

    }
};