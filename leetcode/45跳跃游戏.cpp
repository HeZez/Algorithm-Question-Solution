/*
    给定一个非负整数数组，你最初位于数组的第一个位置。

    数组中的每个元素代表你在该位置可以跳跃的最大长度。

    你的目标是使用最少的跳跃次数到达数组的最后一个位置。

    示例:

    输入: [2,3,1,1,4]
    输出: 2
    解释: 跳到最后一个位置的最小跳跃数是 2。
         从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
    说明:

    假设你总是可以到达数组的最后一个位置。

*/
/*
    这道题不是贪心，很容易有局部最优的情况
    考虑动态规划或者带剪枝的树搜索，
    我个人更倾向于带剪枝的树搜索
    
    但是看了大佬的的思路之后。。。。这道题还是贪心，只不过贪心策略和我想的不一样
    贪心策略是跳到当前能够到达的最远位置，遍历数组，直到可以超过终点
    直观理解就是，能够到达的最远位置，一步就可以到达，，并且从当前位置到最远位置之间的位置都是可供选择的
    走这些可选择的位置都是一步， 接下来在这些一步可以到达的位置中找能够到达的最远的下一个位置，同理这些也是一步可以到达   的，于是以此类推。
    
    实现上可以遍历一遍数组，当前位置为p，先确定最远位置f1，之后遍历当前位置到最远位置之间的距离，
    记录中间这些位置可能到达的最远距离f2，之后在遍历到f1的时候，步数加一，表示从p开始那些走一步可以到达的地方
    都遍历完成了， 接下来p=f1, f1=f2,继续遍历。
    
*/
class Solution {
public:
    int jump(vector<int>& nums) {
        // 如果数组只有一个元素，开始时就在终点，返回0
        if(nums.empty()||nums.size()==1)
            return 0;
        int farthest=0;
        int reach=0;
        int res=0;
        for(int i=0;i<nums.size();i++)
        {
            if(i+nums[i]>farthest)
                farthest=i+nums[i];
            if(farthest>=nums.size()-1)
            {
                res++;
                break;
            }
            if(i==reach)
            {
                res++;
                reach=farthest;
            }
        }
        return res;
    }
};