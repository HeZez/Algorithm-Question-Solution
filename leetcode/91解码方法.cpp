/*
    一条包含字母 A-Z 的消息通过以下方式进行了编码：

    'A' -> 1
    'B' -> 2
    ...
    'Z' -> 26
    给定一个只包含数字的非空字符串，请计算解码方法的总数。

    示例 1:

    输入: "12"
    输出: 2
    解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
    示例 2:

    输入: "226"
    输出: 3
    解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
*/
/*
    ascii码 0的十进制是48
    比较惭愧，我是通过动态规划的分类点进这道题的，所以受到了暗示要使用动态的规划解题
    我认为递归方程是，用dp[n]表示长度为n的字符串的解码方法种类，则
    dp[n]=dp[n-1]    if 最新一位数字与前一位组合起来大于26
         =dp[n-1]+1   if 小于26
         dp[0]=0       dp[1]=1
    注意 测试用例中有0存在 情况更加复杂需要把当前位是0或者不是0分开考虑
    
    评论区分析这个问题的递归方程和斐波那契数的结果类似， 都是dp[i]=dp[i-1]+dp[i-2]
    只不过当s[i-1]=0的时候dp[i-1]=0
*/
    
class Solution {
public:
    int numDecodings(string s) {
        if(s.size()==0||s[0]=='0') return 0;
        int n=s.size();
        vector<int> dp(n+1,0);
        dp[0]=1;
        dp[1]=1;
        for(int i=1;i<n;i++)
        {
            if(s[i]=='0') 
                dp[i+1]=0;
            else
                dp[i+1]=dp[i];
            if(s[i-1]-48==1||(s[i-1]-48==2&&s[i]-48<=6))
                dp[i+1]+=dp[i-1];
        }
        return dp[n];
    }
};